const axios = require('axios');
const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.printf(({ timestamp, level, message }) => {
      return `${timestamp} [LINE-API] [${level.toUpperCase()}]: ${message}`;
    })
  ),
  transports: [
    new winston.transports.Console()
  ]
});

class LineNotificationService {
  constructor() {
    this.channelAccessToken = process.env.LINE_CHANNEL_ACCESS_TOKEN;
    this.channelSecret = process.env.LINE_CHANNEL_SECRET;
    this.userId = process.env.LINE_USER_ID;
    this.messagingApiUrl = 'https://api.line.me/v2/bot';
    this.timeout = 30000; // 30 seconds timeout
  }
    this.lineNotifyUrl = 'https://notify-api.line.me/api/notify';
    this.lineBotUrl = 'https://api.line.me/v2/bot';
  }

  async testConnection() {
    if (!this.lineNotifyToken || this.lineNotifyToken === 'your-line-notify-token-here') {
      throw new Error('LINE Notify token not configured');
    }
    
    try {
      const response = await axios.get('https://notify-api.line.me/api/status', {
        headers: {
          'Authorization': `Bearer ${this.lineNotifyToken}`
        },
        timeout: 8000
      });
      
      return response.status === 200;
    } catch (error) {
      if (error.response?.status === 401) {
        throw new Error('Invalid LINE Notify token');
      }
      if (error.code === 'ECONNABORTED') {
        throw new Error('LINE API connection timeout');
      }
      if (error.code === 'ENOTFOUND') {
        throw new Error('LINE API network error');
      }
      logger.error(`LINE connection test failed: ${error.message}`);
      throw error;
    }
  }

  async sendRiskAlert(highRiskStocks) {
    logger.info(`üö® Sending risk alert for ${highRiskStocks.length} stocks`);
    
    for (const stock of highRiskStocks) {
      try {
        const message = this.formatRiskMessage(stock);
        await this.sendLineNotify(message);
        
        // Add delay between messages
        await this.delay(2000);
        
      } catch (error) {
        logger.error(`‚ùå Failed to send risk alert for ${stock.symbol}: ${error.message}`);
      }
    }
  }

  async sendOpportunityAlert(opportunities) {
    logger.info(`üî• Sending opportunity alert for ${opportunities.length} stocks`);
    
    for (const stock of opportunities) {
      try {
        const message = this.formatOpportunityMessage(stock);
        await this.sendLineNotify(message);
        
        // Add delay between messages
        await this.delay(2000);
        
      } catch (error) {
        logger.error(`‚ùå Failed to send opportunity alert for ${stock.symbol}: ${error.message}`);
      }
    }
  }

  async sendErrorNotification(error) {
    try {
      const message = `üö® [‡∏£‡∏∞‡∏ö‡∏ö‡∏Ç‡∏±‡∏î‡∏Ç‡πâ‡∏≠‡∏á] AOM Stock Notification

‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ${error.message}

‡πÄ‡∏ß‡∏•‡∏≤: ${new Date().toLocaleString('th-TH', { timeZone: 'Asia/Bangkok' })}

‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏ö‡∏ö`;

      await this.sendLineNotify(message);
      
    } catch (lineError) {
      logger.error(`‚ùå Failed to send error notification: ${lineError.message}`);
    }
  }

  async handleIncomingMessage(event) {
    try {
      if (event.type === 'message' && event.message.type === 'text') {
        const userMessage = event.message.text;
        const userId = event.source.userId;
        
        logger.info(`üì® Received message from ${userId}: ${userMessage}`);
        
        // Analyze user query with AI
        const response = await this.analyzeUserQuery(userMessage);
        
        // Send response back to user
        await this.replyToUser(event.replyToken, response);
      }
      
    } catch (error) {
      logger.error(`‚ùå Error handling incoming message: ${error.message}`);
    }
  }

  async analyzeUserQuery(userMessage) {
    try {
      // Get stock context from Stock Data Service
      const StockDataService = require('./stockDataService');
      const stockDataService = new StockDataService();
      const stockContext = await stockDataService.getStockContext();
      
      // Analyze with ChatGPT
      const NewsAnalysisService = require('./newsAnalysisService');
      const newsAnalysis = new NewsAnalysisService();
      
      const prompt = `‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ñ‡∏≤‡∏°: "${userMessage}"

‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏∏‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ:
${stockContext}

‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏≠‡∏ö‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏•‡∏á‡∏ó‡∏∏‡∏ô‡πÅ‡∏•‡∏∞‡∏´‡∏∏‡πâ‡∏ô‡πÉ‡∏ô‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ ‡πÇ‡∏î‡∏¢:
1. ‡πÉ‡∏´‡πâ‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏ä‡∏ô‡πå
2. ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á
3. ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏Å‡∏≤‡∏£‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£ (‡∏´‡∏≤‡∏Å‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°)
4. ‡∏ï‡∏≠‡∏ö‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢‡πÉ‡∏´‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏á‡πà‡∏≤‡∏¢
5. ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô 500 ‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£

‡∏´‡∏≤‡∏Å‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏•‡∏á‡∏ó‡∏∏‡∏ô ‡πÉ‡∏´‡πâ‡πÅ‡∏à‡πâ‡∏á‡∏ß‡πà‡∏≤‡∏£‡∏∞‡∏ö‡∏ö‡∏ô‡∏µ‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∂‡∏Å‡∏©‡∏≤‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏∏‡πâ‡∏ô‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô`;

      const response = await axios.post('https://api.openai.com/v1/chat/completions', {
        model: "gpt-3.5-turbo",
        messages: [{ role: "user", content: prompt }],
        max_tokens: 800,
        temperature: 0.7
      }, {
        headers: {
          'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
          'Content-Type': 'application/json'
        }
      });

      return response.data.choices[0].message.content;
      
    } catch (error) {
      logger.error(`‚ùå Failed to analyze user query: ${error.message}`);
      return `‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢ ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡πÑ‡∏î‡πâ‡πÉ‡∏ô‡∏Ç‡∏ì‡∏∞‡∏ô‡∏µ‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏∞

Error: ${error.message}`;
    }
  }

  formatRiskMessage(stock) {
    const risk = stock.riskAnalysis;
    const emoji = this.getRiskEmoji(risk.riskLevel);
    
    let message = `üö® [‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á‡∏™‡∏π‡∏á] ${stock.symbol}

${emoji} ‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á: ${this.translateRiskLevel(risk.riskLevel)}

üì∞ ‡∏Ç‡πà‡∏≤‡∏ß: "${risk.keyNews || '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πà‡∏≤‡∏ß‡πÄ‡∏â‡∏û‡∏≤‡∏∞'}"

üìù ‡∏™‡∏£‡∏∏‡∏õ: ${risk.summary}

üìä ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ô‡πà‡∏≤‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏ñ‡∏∑‡∏≠: ${risk.confidenceScore.toFixed(2)}

üìà ‡πÅ‡∏ô‡∏ß‡πÇ‡∏ô‡πâ‡∏°: üîª ${risk.recommendation}`;

    // Add news source if available
    if (stock.news && stock.news.length > 0) {
      const topNews = stock.news[0];
      message += `

üîó ‡πÅ‡∏´‡∏•‡πà‡∏á‡∏Ç‡πà‡∏≤‡∏ß: ${topNews.source}`;
      
      if (topNews.url && topNews.url !== 'undefined') {
        message += `
‡∏•‡∏¥‡∏á‡∏Å‡πå: ${topNews.url}`;
      }
    }

    message += `

‚è∞ ‡πÄ‡∏ß‡∏•‡∏≤: ${new Date().toLocaleString('th-TH', { timeZone: 'Asia/Bangkok' })}`;

    return message;
  }

  formatOpportunityMessage(stock) {
    const opportunity = stock.opportunityAnalysis;
    const emoji = this.getOpportunityEmoji(opportunity.opportunityLevel);
    
    let message = `üî• [‡πÇ‡∏≠‡∏Å‡∏≤‡∏™‡∏Ç‡∏∂‡πâ‡∏ô] ${stock.symbol}

${emoji} ‡∏£‡∏∞‡∏î‡∏±‡∏ö‡πÇ‡∏≠‡∏Å‡∏≤‡∏™: ${this.translateOpportunityLevel(opportunity.opportunityLevel)}

üì∞ ‡∏Ç‡πà‡∏≤‡∏ß: "${opportunity.keyNews || '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πà‡∏≤‡∏ß‡πÄ‡∏â‡∏û‡∏≤‡∏∞'}"

üìù ‡∏™‡∏£‡∏∏‡∏õ: ${opportunity.summary}

üìä ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ô‡πà‡∏≤‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏ñ‡∏∑‡∏≠: ${opportunity.confidenceScore.toFixed(2)}

üìà ‡πÅ‡∏ô‡∏ß‡πÇ‡∏ô‡πâ‡∏°: üî∫ ‡∏´‡∏∏‡πâ‡∏ô‡∏°‡∏µ‡πÇ‡∏≠‡∏Å‡∏≤‡∏™‡∏Ç‡∏∂‡πâ‡∏ô

‚è±Ô∏è ‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤‡∏Ñ‡∏≤‡∏î‡∏Å‡∏≤‡∏£‡∏ì‡πå: ${opportunity.timeframe}`;

    if (opportunity.priceTarget) {
      message += `
üéØ ‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏£‡∏≤‡∏Ñ‡∏≤: ${opportunity.priceTarget}`;
    }

    // Add news source if available
    if (stock.news && stock.news.length > 0) {
      const topNews = stock.news[0];
      message += `

üîó ‡πÅ‡∏´‡∏•‡πà‡∏á‡∏Ç‡πà‡∏≤‡∏ß: ${topNews.source}`;
      
      if (topNews.url && topNews.url !== 'undefined') {
        message += `
‡∏•‡∏¥‡∏á‡∏Å‡πå: ${topNews.url}`;
      }
    }

    message += `

‚è∞ ‡πÄ‡∏ß‡∏•‡∏≤: ${new Date().toLocaleString('th-TH', { timeZone: 'Asia/Bangkok' })}`;

    return message;
  }

  async sendLineNotify(message) {
    try {
      const response = await axios.post(this.lineNotifyUrl, 
        `message=${encodeURIComponent(message)}`,
        {
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            'Authorization': `Bearer ${this.lineNotifyToken}`
          }
        }
      );
      
      logger.info(`‚úÖ LINE notification sent successfully`);
      return response.data;
      
    } catch (error) {
      logger.error(`‚ùå Failed to send LINE notification: ${error.message}`);
      throw error;
    }
  }

  async replyToUser(replyToken, message) {
    try {
      const response = await axios.post(`${this.lineBotUrl}/message/reply`, {
        replyToken: replyToken,
        messages: [{
          type: 'text',
          text: message
        }]
      }, {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.lineBotToken}`
        }
      });
      
      logger.info(`‚úÖ Reply sent successfully`);
      return response.data;
      
    } catch (error) {
      logger.error(`‚ùå Failed to reply to user: ${error.message}`);
      throw error;
    }
  }

  getRiskEmoji(riskLevel) {
    switch (riskLevel) {
      case 'critical': return 'üíÄ';
      case 'high': return 'üö®';
      case 'medium': return '‚ö†Ô∏è';
      case 'low': return '‚ö°';
      default: return '‚ùì';
    }
  }

  getOpportunityEmoji(opportunityLevel) {
    switch (opportunityLevel) {
      case 'excellent': return 'üöÄ';
      case 'high': return 'üî•';
      case 'medium': return 'üìà';
      case 'low': return 'üí°';
      default: return '‚ùì';
    }
  }

  translateRiskLevel(level) {
    switch (level) {
      case 'critical': return '‡∏ß‡∏¥‡∏Å‡∏§‡∏ï';
      case 'high': return '‡∏™‡∏π‡∏á';
      case 'medium': return '‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á';
      case 'low': return '‡∏ï‡πà‡∏≥';
      default: return '‡πÑ‡∏°‡πà‡∏ó‡∏£‡∏≤‡∏ö';
    }
  }

  translateOpportunityLevel(level) {
    switch (level) {
      case 'excellent': return '‡∏î‡∏µ‡πÄ‡∏¢‡∏µ‡πà‡∏¢‡∏°';
      case 'high': return '‡∏™‡∏π‡∏á';
      case 'medium': return '‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á';
      case 'low': return '‡∏ï‡πà‡∏≥';
      default: return '‡πÑ‡∏°‡πà‡∏ó‡∏£‡∏≤‡∏ö';
    }
  }

  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

module.exports = LineNotificationService;