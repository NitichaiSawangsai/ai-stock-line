require('dotenv').config();
const cron = require('node-cron');
const moment = require('moment-timezone');
const winston = require('winston');
const StockDataService = require('./services/stockDataService');
const NewsAnalysisService = require('./services/newsAnalysisService');
const LineOfficialAccountService = require('./services/lineOfficialAccountService');
const SchedulerService = require('./services/schedulerService');
const { AutoRecoveryDataService } = require('./services/autoRecoveryDataService');

// Configure logger
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.printf(({ timestamp, level, message }) => {
      return `${timestamp} [${level.toUpperCase()}]: ${message}`;
    })
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'logs/app.log' })
  ]
});

class StockNotificationApp {
  constructor() {
    this.isRunning = false;
    this.startTime = null;
    this.timeout = 20 * 60 * 1000; // 20 minutes timeout
    this.stockData = new StockDataService();
    this.newsAnalysis = new NewsAnalysisService();
    this.lineNotification = new LineOfficialAccountService();
    this.scheduler = new SchedulerService();
    this.autoRecoveryData = new AutoRecoveryDataService(); // Enhanced data service with auto-recovery
    this.sessionData = {
      startTime: null,
      processedStocks: 0,
      errors: [],
      lineFallbackUsed: false,
      detectedModels: [],
      costLimitExceeded: false,
      tokensUsed: 0,
      costThisSession: '0.00',
      monthlyTokens: '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•',
      monthlyCost: '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•',
      costStatus: null,
      modelsUsed: '',
      duration: 0,
      newsCount: 0,
      analysisResults: []
    };
    
    // Monthly cost limit from .env
    this.monthlyCostLimitTHB = parseFloat(process.env.MONTHLY_COST_LIMIT_THB) || 100;
    this.currentMonthlyCostTHB = 0;
  }

  /**
   * Check monthly cost limit and switch to free models if exceeded
   * üí∞ ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏Ñ‡πà‡∏≤‡πÉ‡∏ä‡πâ‡∏à‡πà‡∏≤‡∏¢‡∏£‡∏≤‡∏¢‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏à‡∏≤‡∏Å .env ‡πÅ‡∏•‡∏∞‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÑ‡∏õ‡πÉ‡∏ä‡πâ‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏ü‡∏£‡∏µ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
   */
  async checkMonthlyCostLimit() {
    try {
      // Read current monthly cost from cost tracking service
      const fs = require('fs').promises;
      const costFilePath = './data/monthly-cost.json';
      
      try {
        const costData = await fs.readFile(costFilePath, 'utf8');
        const monthlyCost = JSON.parse(costData);
        this.currentMonthlyCostTHB = monthlyCost.totalCostTHB || 0;
      } catch (error) {
        // File doesn't exist or invalid, start with 0
        this.currentMonthlyCostTHB = 0;
      }
      
      logger.info(`üí∞ Monthly cost limit: ${this.monthlyCostLimitTHB} THB`);
      logger.info(`üí∞ Current monthly cost: ${this.currentMonthlyCostTHB} THB`);
      
      if (this.currentMonthlyCostTHB >= this.monthlyCostLimitTHB) {
        this.sessionData.costLimitExceeded = true;
        logger.warn(`‚ö†Ô∏è Monthly cost limit exceeded! Switching to free models`);
        logger.warn(`üí∏ Current: ${this.currentMonthlyCostTHB} THB >= Limit: ${this.monthlyCostLimitTHB} THB`);
        
        // Switch to free models automatically
        process.env.OPENAI_API_KEY = 'disabled';
        process.env.GEMINI_API_KEY = 'free';
        
        logger.info('üÜì Switched to: google/gemini-free, openai/disabled');
        return true; // Cost limit exceeded
      } else {
        const remainingBudget = this.monthlyCostLimitTHB - this.currentMonthlyCostTHB;
        logger.info(`üíö Within budget. Remaining: ${remainingBudget.toFixed(2)} THB`);
        return false; // Within limit
      }
    } catch (error) {
      logger.error(`‚ùå Error checking cost limit: ${error.message}`);
      return false;
    }
  }

  /**
   * Detect actual models from .env configuration
   * ü§ñ ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏à‡∏£‡∏¥‡∏á‡∏à‡∏≤‡∏Å .env
   */
  detectActualModels() {
    const models = [];
    
    // Check Gemini model
    if (process.env.GEMINI_API_KEY && process.env.GEMINI_MODEL && process.env.GEMINI_API_KEY !== 'free') {
      models.push(`google/${process.env.GEMINI_MODEL}`);
    } else {
      models.push('google/gemini-free');
    }
    
    // Check OpenAI model
    if (process.env.OPENAI_API_KEY && process.env.OPENAI_MODEL && process.env.OPENAI_API_KEY !== 'disabled') {
      models.push(`openai/${process.env.OPENAI_MODEL}`);
    } else {
      models.push('openai/disabled');
    }
    
    this.sessionData.detectedModels = models;
    this.sessionData.modelsUsed = models.join(', '); // Update session data
    
    if (this.sessionData.costLimitExceeded) {
      logger.warn(`‚ö†Ô∏è Monthly cost limit exceeded! Using FREE models: ${models.join(', ')}`);
    } else {
      logger.info(`ü§ñ Detected models: ${models.join(', ')}`);
    }
    
    return models;
  }

  /**
   * Enhanced LINE notification with fallback to output-summary.txt
   * üíæ ‡∏ñ‡πâ‡∏≤ LINE ‡∏™‡πà‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ ‡πÉ‡∏´‡πâ‡∏£‡∏ß‡∏ö‡∏£‡∏ß‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÑ‡∏õ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå output-summary.txt
   */
  async sendWithLineFallback(sendFunction, data, label) {
    try {
      // Handle different types of LINE service methods
      if (typeof sendFunction === 'string') {
        // Check if the method exists on lineNotification
        if (typeof this.lineNotification[sendFunction] === 'function') {
          await this.lineNotification[sendFunction](data);
        } else {
          // Fallback to sendMessage for unrecognized methods
          await this.lineNotification.sendMessage(data);
        }
      } else if (typeof sendFunction === 'function') {
        // If sendFunction is a bound method
        await sendFunction.call(this.lineNotification, data);
      } else {
        // Default fallback for sendMessage
        await this.lineNotification.sendMessage(data);
      }
      logger.info(`‚úÖ Successfully sent ${label} to LINE`);
      return true;
    } catch (error) {
      logger.warn(`‚ö†Ô∏è Failed to send ${label} to LINE: ${error.message}`);
      this.sessionData.lineFallbackUsed = true;
      this.sessionData.errors.push(`LINE_FAILED_${label}: ${error.message}`);
      
      // Save to fallback file
      await this.saveToFallbackFile(data, label);
      return false;
    }
  }

  /**
   * Clear output-summary.txt file before starting new session
   */
  async clearOutputFile() {
    const fs = require('fs').promises;
    const path = require('path');
    
    try {
      const outputPath = path.join(__dirname, 'data', 'output-summary.txt');
      await fs.unlink(outputPath);
      logger.info('üóëÔ∏è ‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå output-summary.txt ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß');
    } catch (error) {
      if (error.code !== 'ENOENT') {
        logger.warn(`‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå output-summary.txt: ${error.message}`);
      }
      // ‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÑ‡∏ü‡∏•‡πå‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡∏Å‡πá‡πÑ‡∏°‡πà‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏£
    }
  }

  /**
   * Clear output-summary.txt file before starting new analysis
   * ‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå output-summary.txt ‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÉ‡∏´‡∏°‡πà
   */
  async clearOutputFile() {
    const fs = require('fs').promises;
    const path = require('path');
    
    try {
      const outputPath = path.join(__dirname, 'data', 'output-summary.txt');
      
      // ‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà
      try {
        await fs.unlink(outputPath);
        logger.info('üóëÔ∏è ‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå output-summary.txt ‡πÄ‡∏Å‡πà‡∏≤‡πÅ‡∏•‡πâ‡∏ß');
      } catch (error) {
        // ‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏Å‡πá‡πÑ‡∏°‡πà‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏£
        if (error.code !== 'ENOENT') {
          logger.warn(`‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏Å‡πà‡∏≤‡πÑ‡∏î‡πâ: ${error.message}`);
        }
      }
      
      // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏´‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏´‡∏±‡∏ß‡∏Ç‡πâ‡∏≠
      const timestamp = new Date().toISOString();
      const thaiTime = new Date().toLocaleString('th-TH', { timeZone: 'Asia/Bangkok' });
      
      const initialContent = `=== ‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏Ç‡πà‡∏≤‡∏ß‡∏â‡∏ö‡∏±‡∏ö‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå - ${timestamp} ===
üì∞ ‡∏™‡∏£‡∏∏‡∏õ‡∏Ç‡πà‡∏≤‡∏ß‡∏´‡∏∏‡πâ‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
üïê ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå: ${thaiTime} (‡πÄ‡∏ß‡∏•‡∏≤‡∏õ‡∏£‡∏∞‡πÄ‡∏ó‡∏®‡πÑ‡∏ó‡∏¢)

`;
      
      await fs.writeFile(outputPath, initialContent);
      logger.info('üìÑ ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå output-summary.txt ‡πÉ‡∏´‡∏°‡πà‡πÅ‡∏•‡πâ‡∏ß');
      
    } catch (error) {
      logger.error(`‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÑ‡∏ü‡∏•‡πå output-summary.txt ‡πÑ‡∏î‡πâ: ${error.message}`);
    }
  }

  /**
   * Clear output file before starting new session
   */
  async clearOutputFile() {
    const fs = require('fs').promises;
    const path = require('path');
    
    try {
      const outputPath = path.join(__dirname, 'data', 'output-summary.txt');
      await fs.unlink(outputPath);
      logger.info('üóëÔ∏è ‡∏•‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå output-summary.txt ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß');
    } catch (error) {
      if (error.code !== 'ENOENT') {
        logger.warn(`‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå output: ${error.message}`);
      }
    }
  }

  /**
   * Save data to output-summary.txt when LINE fails
   * Enhanced format with complete news details, analysis, and summaries
   */
  async saveToFallbackFile(data, label) {
    const fs = require('fs').promises;
    const timestamp = new Date().toISOString();
    
    let content = `\n=== ${label} - ${timestamp} ===\n`;
    
    // Handle different types of content
    if (label === 'SESSION_REPORT') {
      content += this.formatSessionReport(data);
    } else if (label === 'RISK_ALERT' || label === 'OPPORTUNITY_ALERT') {
      content += this.formatStockAlert(data, label);
    } else if (label === 'COST_REPORT') {
      content += this.formatCostReport(data);
    } else {
      // Generic formatting
      if (typeof data === 'string') {
        content += data;
      } else if (data && typeof data === 'object') {
        content += JSON.stringify(data, null, 2);
      } else {
        content += String(data);
      }
    }
    
    content += '\n' + '='.repeat(80) + '\n';
    
    try {
      const path = require('path');
      const outputPath = path.join(__dirname, 'data', 'output-summary.txt');
      await fs.appendFile(outputPath, content);
      logger.info(`üíæ Saved ${label} to data/output-summary.txt`);
    } catch (error) {
      logger.error(`‚ùå Failed to save to fallback file: ${error.message}`);
    }
  }

  /**
   * Format session report for detailed output
   */
  formatSessionReport(data) {
    let report = `üìä ‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡πÄ‡∏ã‡∏™‡∏ä‡∏±‡∏ô\n`;
    report += `‚è±Ô∏è ‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤: ${this.sessionData.duration} ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡∏µ\n`;
    report += `üìà ‡∏´‡∏∏‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•: ${this.sessionData.processedStocks} ‡∏ï‡∏±‡∏ß\n`;
    report += `ü§ñ ‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ: ${this.sessionData.modelsUsed}\n`;
    
    // Cost information
    if (this.sessionData.costStatus) {
      report += `üí∞ ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ñ‡πà‡∏≤‡πÉ‡∏ä‡πâ‡∏à‡πà‡∏≤‡∏¢: ${this.sessionData.costStatus}\n`;
    }
    
    // News information
    if (this.sessionData.newsCount !== undefined) {
      report += `üì∞ ‡∏Ç‡πà‡∏≤‡∏ß‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á: ${this.sessionData.newsCount} ‡∏´‡∏∏‡πâ‡∏ô\n`;
    }
    
    report += `‚ùå ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ${this.sessionData.errors.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£\n`;
    report += `üíæ ‡πÉ‡∏ä‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡∏™‡∏≥‡∏£‡∏≠‡∏á: ${this.sessionData.lineFallbackUsed ? '‡πÉ‡∏ä‡πà' : '‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà'}\n`;
    
    if (this.sessionData.errors.length > 0) {
      report += `\nüö® Error Details:\n`;
      this.sessionData.errors.forEach((error, index) => {
        report += `   ${index + 1}. ${error}\n`;
      });
    }
    
    return report;
  }

  /**
   * Format stock alert for detailed output
   */
  formatStockAlert(data, alertType) {
    if (typeof data === 'string') {
      return this.formatDetailedStockData(data, alertType);
    }
    return data;
  }

  /**
   * Format detailed stock data similar to user's desired format
   */
  formatDetailedStockData(content, alertType) {
    // This is where we'll parse the stock analysis content
    // and format it according to the user's desired format
    
    const lines = content.split('\n');
    let formattedContent = '';
    let currentStock = '';
    let stockCount = 0;
    
    for (const line of lines) {
      if (line.includes('üì∞') && line.includes('‡∏´‡∏∏‡πâ‡∏ô')) {
        stockCount++;
        currentStock = line;
        formattedContent += `\n${line}\n\n`;
        formattedContent += `üíº ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏•‡∏á‡∏ó‡∏∏‡∏ô: 0.00 (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏î‡∏π)\n`;
        formattedContent += `üìÖ ‡∏Ç‡πà‡∏≤‡∏ß‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á 7 ‡∏ß‡∏±‡∏ô: [‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•] ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£\n\n`;
      } else if (line.includes('‡∏Ç‡πà‡∏≤‡∏ß‡∏ó‡∏µ‡πà')) {
        formattedContent += `${line}\n\n`;
      } else if (line.includes('‡∏™‡∏£‡∏∏‡∏õ:')) {
        formattedContent += `üìù ${line}\n\n`;
      } else if (line.includes('‡∏ú‡∏•‡∏Å‡∏£‡∏∞‡∏ó‡∏ö')) {
        formattedContent += `üí° ${line}\n\n`;
      } else if (line.includes('‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏£‡∏≤‡∏Ñ‡∏≤')) {
        formattedContent += `üí∞ ${line}\n`;
      } else if (line.includes('‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤')) {
        formattedContent += `‚è±Ô∏è ${line}\n`;
      } else if (line.includes('‡∏Ñ‡∏ß‡∏≤‡∏°‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à')) {
        formattedContent += `üéØ ${line}\n\n`;
      } else if (line.includes('‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà')) {
        formattedContent += `üìÖ ${line}\n`;
      } else if (line.includes('‡πÅ‡∏´‡∏•‡πà‡∏á‡∏Ç‡πà‡∏≤‡∏ß')) {
        formattedContent += `üè¢ ${line}\n`;
      } else if (line.includes('‡∏≠‡πà‡∏≤‡∏ô‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°')) {
        formattedContent += `üîó ${line}\n\n`;
      } else if (line.includes('‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó')) {
        formattedContent += `‚è∞ ${line}\n\n`;
        formattedContent += '---'.repeat(10) + '\n';
      } else if (line.trim() && !line.includes('=')){
        formattedContent += `${line}\n`;
      }
    }
    
    // Add summary at the end
    if (alertType === 'RISK_ALERT' || alertType === 'OPPORTUNITY_ALERT') {
      formattedContent += this.generateAnalysisSummary();
    }
    
    return formattedContent;
  }

  /**
   * Generate analysis summary with token usage and costs
   */
  generateAnalysisSummary() {
    let summary = '\n' + '='.repeat(60) + '\n';
    summary += `üìä ‡∏™‡∏£‡∏∏‡∏õ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ô‡∏µ‡πâ\n\n`;
    
    // Current session usage
    summary += `üîπ Token ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ô‡∏µ‡πâ: ${this.sessionData.tokensUsed || '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì'}\n`;
    summary += `üîπ ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ô‡∏µ‡πâ: ${this.sessionData.costThisSession || '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì'} ‡∏ö‡∏≤‡∏ó\n`;
    summary += `üîπ Model AI ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå: ${this.sessionData.modelsUsed}\n\n`;
    
    // Monthly summary
    summary += `üìà ‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•‡∏£‡∏≤‡∏¢‡πÄ‡∏î‡∏∑‡∏≠‡∏ô\n`;
    summary += `üî∏ Token ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏õ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ: ${this.sessionData.monthlyTokens || '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•'}\n`;
    summary += `üî∏ ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏õ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ: ${this.sessionData.monthlyCost || '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•'} ‡∏ö‡∏≤‡∏ó\n`;
    
    // Cost limit status
    if (this.sessionData.costStatus && this.sessionData.costStatus.includes('EXCEEDED')) {
      summary += `‚ö†Ô∏è ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞: ‡πÄ‡∏Å‡∏¥‡∏ô‡∏Ç‡∏µ‡∏î‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏á‡∏ö‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì‡∏£‡∏≤‡∏¢‡πÄ‡∏î‡∏∑‡∏≠‡∏ô\n`;
      summary += `üìã ‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏ü‡∏£‡∏µ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥\n`;
    } else {
      summary += `‚úÖ ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞: ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏Ç‡∏µ‡∏î‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏á‡∏ö‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì\n`;
    }
    
    summary += '\n' + '='.repeat(60) + '\n';
    return summary;
  }

  /**
   * Format cost report for detailed output
   */
  formatCostReport(data) {
    if (typeof data === 'string') {
      return data;
    }
    
    let report = `üí∞ COST REPORT\n`;
    if (data.currentCost) report += `üí∏ Current cost: ${data.currentCost} THB\n`;
    if (data.limit) report += `üéØ Monthly limit: ${data.limit} THB\n`;
    if (data.status) report += `üìä Status: ${data.status}\n`;
    if (data.models) report += `ü§ñ Active models: ${data.models}\n`;
    
    return report;
  }

  /**
   * Send session report to LINE
   * üìä ‡∏™‡∏£‡∏∏‡∏õ‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô (Session Report) ‡πÉ‡∏´‡πâ‡∏™‡∏£‡∏∏‡∏õ‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏ó‡∏µ‡πà‡πÑ‡∏•‡∏ô‡πå‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á
   */
  async sendSessionReport() {
    const endTime = Date.now();
    this.sessionData.duration = Math.round((endTime - this.sessionData.startTime) / 1000);
    
    // Update cost status for the session
    this.sessionData.costStatus = this.sessionData.costLimitExceeded ? 
      `üí∏ COST LIMIT EXCEEDED (${this.currentMonthlyCostTHB}/${this.monthlyCostLimitTHB} THB)` :
      `üíö Within budget (${this.currentMonthlyCostTHB.toFixed(2)}/${this.monthlyCostLimitTHB} THB)`;
    
    this.sessionData.modelsUsed = this.sessionData.detectedModels.join(', ');
    
    // Try to get current session cost from cost tracking service
    try {
      const costTracker = require('./services/costTrackingService');
      if (costTracker && typeof costTracker.getCurrentSessionCost === 'function') {
        this.sessionData.costThisSession = await costTracker.getCurrentSessionCost();
        this.sessionData.tokensUsed = await costTracker.getCurrentSessionTokens();
      }
    } catch (error) {
      logger.warn(`‚ö†Ô∏è Could not retrieve session cost: ${error.message}`);
    }
    
    // Try to get monthly totals
    try {
      const fs = require('fs').promises;
      const costData = await fs.readFile('./data/monthly-cost.json', 'utf8');
      const monthlyCost = JSON.parse(costData);
      this.sessionData.monthlyCost = `${monthlyCost.totalCostTHB || 0} ‡∏ö‡∏≤‡∏ó`;
      this.sessionData.monthlyTokens = monthlyCost.totalTokens || '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•';
    } catch (error) {
      // Keep default values
    }
    
    const reportText = `üìä SESSION REPORT\n` +
      `‚è±Ô∏è Duration: ${this.sessionData.duration} seconds\n` +
      `üìà Stocks processed: ${this.sessionData.processedStocks}\n` +
      `ü§ñ Models: ${this.sessionData.modelsUsed}\n` +
      `üí∞ Cost status: ${this.sessionData.costStatus}\n` +
      `‚ùå Errors: ${this.sessionData.errors.length}\n` +
      `üíæ Fallback used: ${this.sessionData.lineFallbackUsed ? 'Yes' : 'No'}\n` +
      (this.sessionData.errors.length > 0 ? `üîç Recent errors: ${this.sessionData.errors.slice(0, 3).join(', ')}` : '');
    
    await this.sendWithLineFallback(
      'sendMessage',
      reportText,
      'SESSION_REPORT'
    );
  }

  async start() {
    const timeoutId = setTimeout(() => {
      logger.error('‚è∞ Process timeout reached (20 minutes), forcing exit...');
      process.exit(1);
    }, this.timeout);

    try {
      this.startTime = Date.now();
      this.isRunning = true;
      this.sessionData.startTime = this.startTime;
      
      logger.info('üöÄ Stock Notification System Starting...');
      
      // Check monthly cost limit first
      await this.checkMonthlyCostLimit();
      
      // Detect actual models from .env
      this.detectActualModels();
      
      // Check if this is a scheduled run or manual run
      const args = process.argv.slice(2);
      const runType = args.includes('--risk') ? 'risk' : 
                     args.includes('--opportunity') ? 'opportunity' : 
                     args.includes('--dev') ? 'dev' : 'full';

      switch (runType) {
        case 'risk':
          await this.checkHighRiskStocks();
          break;
        case 'opportunity':
          await this.checkStockOpportunities();
          break;
        case 'dev':
          await this.runDevelopmentMode();
          break;
        default:
          await this.runFullCheck();
      }

      // Send session report at the end
      await this.sendSessionReport();

      clearTimeout(timeoutId);
      this.gracefulExit(0);
      
    } catch (error) {
      clearTimeout(timeoutId);
      logger.error(`‚ùå Application error: ${error.message}`);
      
      // Try to send error notification but don't wait if it fails
      try {
        await Promise.race([
          this.lineNotification.sendErrorNotification(error),
          new Promise((_, reject) => setTimeout(() => reject(new Error('Notification timeout')), 5000))
        ]);
      } catch (notifyError) {
        logger.warn(`‚ö†Ô∏è Failed to send error notification: ${notifyError.message}`);
      }
      
      this.forceExit(1);
    }
  }

  async runFullCheck() {
    logger.info('üîç Running full stock analysis...');
    
    try {
      // Clear previous output file first
      await this.clearOutputFile();
      
      // Load stock list from Stock Data Service
      logger.info('üìÇ Loading stock list...');
      const stocks = await this.stockData.getStockList();
      
      if (!stocks || stocks.length === 0) {
        logger.warn('‚ö†Ô∏è No stocks found in the list');
        return;
      }

      logger.info(`üìä Found ${stocks.length} stocks to analyze`);
      this.sessionData.processedStocks = stocks.length;

      // Check for high-risk stocks
      logger.info('üö® Analyzing high-risk stocks...');
      const highRiskStocks = await this.newsAnalysis.analyzeHighRiskStocks(stocks);
      logger.info(`üö® Found ${highRiskStocks.length} high-risk stocks`);
      
      if (highRiskStocks.length > 0) {
        logger.info('üì§ Sending risk alert...');
        await this.sendWithLineFallback(
          'sendRiskAlert',
          highRiskStocks,
          'RISK_ALERT'
        );
        logger.info('‚úÖ Risk alert processed');
      } else {
        logger.info('‚úÖ No high-risk stocks to report');
      }

      // Check for opportunities
      const currentHour = moment().tz('Asia/Bangkok').hour();
      logger.info(`üï∞Ô∏è Current hour: ${currentHour} (Bangkok time)`);
      
      logger.info('üî• Analyzing stock opportunities...');
      const opportunities = await this.newsAnalysis.analyzeStockOpportunities(stocks);
      logger.info(`üî• Found ${opportunities.length} opportunities`);
      
      if (opportunities.length > 0) {
        logger.info('üì§ Sending opportunity alert...');
        await this.sendWithLineFallback(
          'sendOpportunityAlert',
          opportunities,
          'OPPORTUNITY_ALERT'
        );
        logger.info('‚úÖ Opportunity alert processed');
      } else {
        logger.info('‚úÖ No opportunities to report');
      }

      // Send all news data
      logger.info('üì∞ Gathering comprehensive news data...');
      const allNewsData = await this.newsAnalysis.gatherAllStockNews(stocks);
      logger.info(`üì∞ Found news for ${allNewsData.length} stocks`);
      
      if (allNewsData.length > 0) {
        logger.info('üì§ Sending comprehensive news alert...');
        await this.sendWithLineFallback(
          'sendAllNewsAlert',
          allNewsData,
          'ALL_NEWS_ALERT'
        );
        logger.info('‚úÖ All news alert processed');
        this.sessionData.newsCount = allNewsData.length;
      } else {
        logger.info('‚ÑπÔ∏è No news data to send');
        this.sessionData.newsCount = 0;
      }

    } catch (error) {
      logger.error(`üí• Error in full check: ${error.message}`);
      this.sessionData.errors.push(`FULL_CHECK_ERROR: ${error.message}`);
      throw error;
    }
  }

  async checkHighRiskStocks() {
    logger.info('üö® Checking for high-risk stocks...');
    
    try {
      const stocks = await this.stockData.getStockList();
      this.sessionData.processedStocks = stocks.length;
      const highRiskStocks = await this.newsAnalysis.analyzeHighRiskStocks(stocks);
      
      if (highRiskStocks.length > 0) {
        await this.sendWithLineFallback(
          'sendRiskAlert',
          highRiskStocks,
          'RISK_ALERT'
        );
        logger.info(`üö® Processed risk alert for ${highRiskStocks.length} stocks`);
      } else {
        logger.info('‚úÖ No high-risk stocks found');
      }
      
    } catch (error) {
      logger.error(`üí• Error checking high-risk stocks: ${error.message}`);
      this.sessionData.errors.push(`RISK_CHECK_ERROR: ${error.message}`);
      throw error;
    }
  }

  async checkStockOpportunities() {
    logger.info('üî• Checking for stock opportunities...');
    
    try {
      const stocks = await this.stockData.getStockList();
      this.sessionData.processedStocks = stocks.length;
      const opportunities = await this.newsAnalysis.analyzeStockOpportunities(stocks);
      
      if (opportunities.length > 0) {
        await this.sendWithLineFallback(
          'sendOpportunityAlert',
          opportunities,
          'OPPORTUNITY_ALERT'
        );
        logger.info(`üî• Processed opportunity alert for ${opportunities.length} stocks`);
      } else {
        logger.info('‚úÖ No opportunities found');
      }
      
    } catch (error) {
      logger.error(`üí• Error checking opportunities: ${error.message}`);
      this.sessionData.errors.push(`OPPORTUNITY_CHECK_ERROR: ${error.message}`);
      throw error;
    }
  }

  async runDevelopmentMode() {
    logger.info('üîß Running in development mode...');
    
    // Test all services
    await this.testServices();
    
    // Run a quick analysis
    await this.runFullCheck();
  }

  async testServices() {
    logger.info('üß™ Testing all services...');
    
    let hasErrors = false;
    
    // Test Stock Data service with timeout
    try {
      await Promise.race([
        this.stockData.testConnection(),
        new Promise((_, reject) => setTimeout(() => reject(new Error('Stock data test timeout')), 10000))
      ]);
      logger.info('‚úÖ Stock data service OK');
    } catch (error) {
      logger.error(`‚ùå Stock data service failed: ${error.message}`);
      hasErrors = true;
    }
    
    // Test AI Services with detailed status
    await this.testAIServices();
    
    // Test LINE notification with timeout
    try {
      await Promise.race([
        this.lineNotification.testConnection(),
        new Promise((_, reject) => setTimeout(() => reject(new Error('LINE test timeout')), 10000))
      ]);
      logger.info('‚úÖ LINE notification service OK');
    } catch (error) {
      logger.error(`‚ùå LINE notification service failed: ${error.message}`);
      hasErrors = true;
    }
    
    // Only throw error if critical services failed (not AI in dev mode)
    if (hasErrors) {
      throw new Error('Critical services failed');
    }
  }

  async testAIServices() {
    logger.info('ü§ñ Testing AI Services...');
    
    // Check AI configuration
    const openaiKey = process.env.OPENAI_API_KEY;
    const geminiKey = process.env.GEMINI_API_KEY;
    const openaiModel = process.env.OPENAI_MODEL || 'gpt-3.5-turbo';
    const geminiModel = process.env.GEMINI_MODEL || 'gemini-1.5-flash';
    
    logger.info('üìã AI Configuration:');
    logger.info(`   OpenAI Key: ${openaiKey === 'disabled' ? 'üî¥ DISABLED' : openaiKey ? 'üü¢ CONFIGURED' : 'üü° NOT SET'}`);
    logger.info(`   OpenAI Model: ${openaiModel}`);
    logger.info(`   Gemini Key: ${geminiKey === 'free' ? 'üÜì FREE MODE' : geminiKey ? 'üü¢ CONFIGURED' : 'üü° NOT SET'}`);
    logger.info(`   Gemini Model: ${geminiModel}`);
    
    // Test OpenAI/ChatGPT
    if (openaiKey && openaiKey !== 'disabled') {
      try {
        logger.info('üß™ Testing OpenAI ChatGPT connection...');
        const testResult = await Promise.race([
          this.newsAnalysis.testOpenAIConnection(),
          new Promise((_, reject) => setTimeout(() => reject(new Error('OpenAI test timeout')), 15000))
        ]);
        
        if (testResult) {
          logger.info(`‚úÖ OpenAI ChatGPT (${openaiModel}) - CONNECTED`);
        } else {
          logger.warn(`‚ö†Ô∏è OpenAI ChatGPT (${openaiModel}) - CONNECTION FAILED`);
        }
      } catch (error) {
        logger.error(`‚ùå OpenAI ChatGPT (${openaiModel}) - ERROR: ${error.message}`);
        if (error.message.includes('401')) {
          logger.error('   üîë Authentication failed - Check API key');
        } else if (error.message.includes('429')) {
          logger.error('   ‚è±Ô∏è Rate limit exceeded - Wait and try again');
        } else if (error.message.includes('timeout')) {
          logger.error('   ‚è∞ Connection timeout - Network issue');
        }
      }
    } else {
      logger.warn(`‚ö†Ô∏è OpenAI ChatGPT - DISABLED (Using Gemini fallback)`);
    }
    
    // Test Gemini
    try {
      logger.info('üß™ Testing Google Gemini connection...');
      const GeminiAnalysisService = require('./services/geminiAnalysisService');
      const geminiService = new GeminiAnalysisService();
      
      const testResult = await Promise.race([
        geminiService.testConnection(),
        new Promise((_, reject) => setTimeout(() => reject(new Error('Gemini test timeout')), 15000))
      ]);
      
      if (testResult) {
        if (geminiKey === 'free') {
          logger.info(`‚úÖ Google Gemini (${geminiModel}) - FREE MODE (Mock responses)`);
        } else {
          logger.info(`‚úÖ Google Gemini (${geminiModel}) - CONNECTED`);
        }
      } else {
        logger.warn(`‚ö†Ô∏è Google Gemini (${geminiModel}) - CONNECTION FAILED`);
      }
      
      // Test actual AI analysis
      try {
        logger.info('üß† Testing AI analysis capability...');
        const testStock = { symbol: 'APPLE', type: '‡∏´‡∏∏‡πâ‡∏ô', amount: 100, unit: '‡∏´‡∏∏‡πâ‡∏ô' };
        const testNews = [{ title: 'Apple quarterly earnings', description: 'Strong financial performance reported' }];
        
        const analysisStart = Date.now();
        const riskResult = await geminiService.analyzeRiskWithAI(testStock, testNews);
        const analysisTime = Date.now() - analysisStart;
        
        logger.info(`‚úÖ AI Analysis test completed in ${analysisTime}ms`);
        logger.info(`   Risk Level: ${riskResult.riskLevel}`);
        logger.info(`   Confidence: ${(riskResult.confidenceScore * 100).toFixed(1)}%`);
        
      } catch (analysisError) {
        logger.error(`‚ùå AI Analysis test failed: ${analysisError.message}`);
        if (analysisError.message.includes('404')) {
          logger.error('   üö´ Model not found - Check model name');
        } else if (analysisError.message.includes('403')) {
          logger.error('   üîë Permission denied - Check API key permissions');
        }
      }
      
    } catch (error) {
      logger.error(`‚ùå Google Gemini (${geminiModel}) - ERROR: ${error.message}`);
      if (error.message.includes('401')) {
        logger.error('   üîë Authentication failed - Check API key');
      } else if (error.message.includes('429')) {
        logger.error('   ‚è±Ô∏è Rate limit exceeded - Wait and try again');
      } else if (error.message.includes('timeout')) {
        logger.error('   ‚è∞ Connection timeout - Network issue');
      }
    }
    
    // Test News Analysis service overall
    try {
      const connectionResult = await Promise.race([
        this.newsAnalysis.testConnection(),
        new Promise((_, reject) => setTimeout(() => reject(new Error('News analysis test timeout')), 10000))
      ]);
      
      if (connectionResult) {
        logger.info('‚úÖ News Analysis service OK (with AI fallback)');
      } else {
        logger.warn('‚ö†Ô∏è News Analysis service degraded (fallback mode)');
      }
    } catch (error) {
      logger.error(`‚ùå News Analysis service failed: ${error.message}`);
    }
  }

  setupCronJobs() {
    logger.info('‚è∞ Setting up cron jobs...');
    
    // High-risk check every hour
    cron.schedule('0 * * * *', async () => {
      logger.info('üïê Running hourly high-risk check...');
      try {
        await this.checkHighRiskStocks();
      } catch (error) {
        logger.error(`‚ùå Hourly check failed: ${error.message}`);
        await this.lineNotification.sendErrorNotification(error);
      }
    }, {
      timezone: 'Asia/Bangkok'
    });

    // Opportunity check at 6:10 AM Bangkok time
    cron.schedule('10 6 * * *', async () => {
      logger.info('üåÖ Running morning opportunity check...');
      try {
        await this.checkStockOpportunities();
      } catch (error) {
        logger.error(`‚ùå Morning check failed: ${error.message}`);
        await this.lineNotification.sendErrorNotification(error);
      }
    }, {
      timezone: 'Asia/Bangkok'
    });

    logger.info('‚úÖ Cron jobs configured successfully');
  }

  gracefulExit(code = 0) {
    this.isRunning = false;
    const duration = Date.now() - this.startTime;
    logger.info(`üèÅ Process completed in ${Math.round(duration / 1000)}s, exiting with code ${code}`);
    process.exit(code);
  }

  forceExit(code = 1) {
    this.isRunning = false;
    const duration = this.startTime ? Date.now() - this.startTime : 0;
    logger.error(`üõë Force exiting after ${Math.round(duration / 1000)}s with code ${code}`);
    
    // Force exit immediately
    setTimeout(() => {
      process.exit(code);
    }, 100);
  }
}

// Handle graceful shutdown
process.on('SIGINT', () => {
  logger.info('üõë Received SIGINT, shutting down gracefully...');
  process.exit(0);
});

process.on('SIGTERM', () => {
  logger.info('üõë Received SIGTERM, shutting down gracefully...');
  process.exit(0);
});

// Handle uncaught exceptions
process.on('uncaughtException', (error) => {
  logger.error(`üí• Uncaught Exception: ${error.message}`);
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  logger.error(`üí• Unhandled Rejection at: ${promise}, reason: ${reason}`);
  process.exit(1);
});

// Start the application
const app = new StockNotificationApp();

// Check if we're running as a one-time job or setting up cron
const args = process.argv.slice(2);
if (args.includes('--setup-cron')) {
  app.setupCronJobs();
  logger.info('üîÑ Cron jobs running... Press Ctrl+C to stop');
} else {
  app.start();
}